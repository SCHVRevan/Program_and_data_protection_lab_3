# Lab_3

## Постановка задачи
Разработать программу для проверки ключей с использованием методов обфускации в целях обеспечения защиты программы от обратной разработки.

## Использованные методы
- Constant Expressions
- False Branches (some don't work on valid password)
- Сode flattening (very simple)

## Описание
Программа проверяет пароли по следующим правилам:  
1. Длина = 32 (значение спрятано за вычислениями через xor)
2. Первый символ == 'E'  
-- если == 'r' -> выполнение пойдёт по промежуточной ветке
3. Символы [1..3] == "1te"  
-- если == 'oot' -> промежуточная ветка, упомянутая пунктом выше
4. Символы [4, 16, 27] == '_', [9, 13, 24] == '$', [19, 21] == '{'  
-- данные условия заданы системой уравнений, что скрывает конкретные значения символов

В ходе проверок изменяется набор глобальных флагов, выполняются "пустые" вычисления, не влияющие на результат выполнения.  
Итоговая проверка заключается в сверке вектора, получаемого логическим "И" и сдвигами значений флагов (в целях усложнения анализа).

Сообщения для вывода скрыты от статического анализа через xor с ключем.

Разработан key_gen на z3.

## Реакции на различные пароли
- Некорректный пароль: What is this bruh? What the pwd is this bruh?
- Пароль, подходящий под промежуточное условие: Nice try but you still have much to learn
- Корректный пароль: Finally! A worthy opponent!

## Примеры паролей
- корректный: E1it_A!!"$!(!$!!_!!{!{!!$!!_!!!!
- промежуточный: root1A!!"2!(!$!!2!!{!{!!7!!3!!!!
- некорректный: happy_new_year_dudes

## Сборка
   ```bash
    make
   ```
